;;; dotcrafter --- Summary
;;; Commentary:
;; When running dotcrafter in a script, org might not be loaded yet
(require 'org)

;;; Code:
(defcustom dotcrafter-dotfiles-folder "~/.dotfiles"
  "The folder where dotfiles and 'org-mode' configuration files are stored."
  :type 'string
  :group 'dotfiles)

(defcustom dotcrafter-output-directory "~"
  "The directory where dotcrafter.el will write out your dotfiles.
This is typically set to the home directory but can be changed
for testing purposes."
  :type 'string
  :group 'dotfiles)

(defcustom dotcrafter-org-files '()
  "The list of `org-mode' files under the `dotcrafter-dotfiles-folder'.
It contain configuration files that should be tangled."
  :type '(list string)
  :group 'dotfiles)

(defcustom dotcrafter-config-files-directory ".files"
  "The directory path inside of `dotcrafter-dotfiles-folder' where
configuration files that should be symbolically linked are stored."
  :type 'string
  :group 'dotfiles)

(defcustom dotcrafter-ensure-output-directories '(".config" ".local/share")
  "List of directories in the output folder that should be created
before linking configuration files."
  :type  '(list string)
  :group 'dotfiles)

(defcustom dotcrafter-tangle-on-save t
  "When t, automatically tangle Org files on save."
  :type 'boolean
  :group 'dotfiles)

(defcustom dotcrafter-keymap-prefix "C-c C-."
  "The prefix for dotcrafter-mode key bindings."
  :type 'string
  :group 'dotfiles)

(defvar dotcrafter-gitignore-marker "\n# -- Generated by dotcrafter.el! --\n\n"
  "The marker string to be placed in the .gitignore file.
The dotfiles repo to indicate where the auto-generated list of ignored
files begins.")

(defun dotcrafter--scan-for-output-files (org-file)
  "Scan for output files in ORG-FILE.
It finds org code block output paths."
  (let ((output-files '())
        (current-match t))
    ;; Get a buffer for the file, either one that is
    ;; already open or open a new one
    (with-current-buffer (or (get-file-buffer org-file)
                             (find-file-noselect org-file))
      ;; Save the current buffer position
      (save-excursion
        ;; Go back to the beginning of the buffer
        (goto-char (point-min))

        ;; Loop until no more matches are found
        (while current-match
          ;; Search for blocks with a :tangle property
          (setq current-match (search-forward ":tangle " nil t))
          (when current-match
            (let ((output-file (thing-at-point 'filename t)))
              ;; If a file path was found, add it to the list
              (unless (or (not output-file)
                          (string-equal output-file "no"))
                (setq output-files (cons output-file
                                         output-files))))))))
    output-files))

(defun dotcrafter--update-gitignore ()
  "Auto generated list of ignored files."
  (let ((output-files '()))
    ;; Gather the list of output files from all Org files
    (dolist (org-file dotcrafter-org-files)
      (setq output-files
            (append output-files
                    (dotcrafter--scan-for-output-files
                     (expand-file-name org-file dotcrafter-dotfiles-folder)))))

    ;; Now that we have the output files, update the .gitignore file
    (let ((gitignore-file (expand-file-name ".gitignore"
                                            dotcrafter-dotfiles-folder)))
      ;; Find the .gitignore buffer and prepare for editing
      (with-current-buffer (or (get-file-buffer gitignore-file)
                               (find-file-noselect gitignore-file))
        (save-excursion
          ;; Find or insert the dotcrafter-gitignore-marker
          (beginning-of-buffer)
          (or (progn
                (search-forward dotcrafter-gitignore-marker nil t))
              (progn
                (end-of-buffer)
                (insert "\n" dotcrafter-gitignore-marker)))

          ;; Delete the rest of the buffer after the marker
          (delete-region (point) (point-max))

          ;; Insert a line for each output file
          (dolist (output-file output-files)
            (insert output-file "\n"))

          ;; Make sure the buffer is saved
          (save-buffer))))))

(defun dotcrafter-tangle-org-file (&optional org-file)
  "Tangles ORG-FILE file relative to the path indotfiles-folder.
If no file is specified, tangle the current file if it is an 'org-mode'
buffer inside of dotfiles-folder."
  (interactive)
  ;; Suppress prompts and messages
  (let ((org-confirm-babel-evaluate nil)
        (message-log-max nil)
        (inhibit-message t))
    (org-babel-tangle-file (expand-file-name org-file dotcrafter-dotfiles-folder))
    ;; TODO: Only update files that are generated by this file!
    (dotcrafter-link-config-files)))

(defun dotcrafter-tangle-org-files ()
  "Tangles all of the .org files in the paths specified by the variable dotfiles-folder"
  (interactive)
  (dolist (org-file dotcrafter-org-files)
    (dotcrafter-tangle-org-file org-file))
  (message "Dotfiles are up to date!"))

(defun dotcrafter--resolve-config-files-path ()
  (expand-file-name dotcrafter-config-files-directory
                    dotcrafter-dotfiles-folder))

(defun dotcrafter--link-config-file (config-file)
  "Get the path parts of each directory and file in  CONFIG-FILE."
  (let* ((path-parts
          (split-string (file-relative-name (expand-file-name config-file)
                                            (dotcrafter--resolve-config-files-path))
                        "/" t))
         (current-path nil))
    ;; Check each "part" of the path to find the right place to create the symlink.
    ;; Whenever path-parts is nil, stop looping!
    (while path-parts
      ;; Create the current path using the first part and remove it from the
      ;; front of the list for future iterations
      (setq current-path (if current-path
                             (concat current-path "/" (car path-parts))
                           (car path-parts)))
      (setq path-parts (cdr path-parts))

      ;; Figure out whether the current source path can be linked to the target path
      (let ((source-path (expand-file-name (concat dotcrafter-config-files-directory "/" current-path)
                                           dotcrafter-dotfiles-folder))
            (target-path (expand-file-name current-path dotcrafter-output-directory)))
        ;; If the file or directory exists, is it a symbolic link?
        (if (file-symlink-p target-path)
            ;; If the symbolic link exists, does it point to the source-path?
            (if (not (string-equal source-path (file-truename target-path)))
                (error "Path already exists with different symlink! %s" target-path)
              ;; Clear path-parts to stop looping
              (setq path-parts '()))
          ;; If the target path is an existing directory, we need to keep
          ;; looping, otherwise we can create a symlink here!
          ;; Otherwise, the file is probably a directory so keep looping
          (when (not (file-directory-p target-path))
            ;; Create a symbolic link to the source-path and
            ;; clear the path-parts so that we stop looping
            (make-symbolic-link source-path target-path)
            (setq path-parts '())))))))

(defun dotcrafter-link-config-files ()
  (interactive)
  (let ((config-files
         (directory-files-recursively
          (dotcrafter--resolve-config-files-path)
          "")))
    ;; Ensure that the expected output directories are already
    ;; created so that links will be created inside
    (dolist (dir dotcrafter-ensure-output-directories)
      (make-directory (expand-file-name dir dotcrafter-output-directory) t))

    ;; Link all of the source config files to the output path
    (dolist (file config-files)
      (dotcrafter--link-config-file file))))

(defun dotcrafter-move-to-config-files (source-path)
  "Move a file from the output path to the configuration path."
  (interactive "FConfiguration path to move: ")
  (let* ((relative-path (file-relative-name (expand-file-name source-path)
                                            dotcrafter-output-directory))
         (dest-path (expand-file-name relative-path
                                      (dotcrafter--resolve-config-files-path)))
         ;; Strip any trailing slash so that we can treat the directory as file
         (dest-path (if (string-suffix-p "/" dest-path)
                        (substring dest-path 0 -1)
                      dest-path)))
    ;; Make sure that the path is under the output directory and that it
    ;; doesn't already exist
    (when (string-prefix-p ".." relative-path)
      (error "Copied path is not inside of config output directory: %s" dotcrafter-output-directory))
    (when (file-exists-p dest-path)
      (error "Can't copy path because it already exists in the configuration directory: %s" dest-path))

    ;; Ensure that parent directories exist and then move the file!
    (make-directory (file-name-directory dest-path) t)
    (rename-file source-path dest-path)

    ;; Relink the path back to the output directory
    (dotcrafter--link-config-file dest-path)))

(defun dotcrafter-update-dotfiles ()
  "Generate and link configuration files to the output directory.

This command handles the full process of \"tangling\" Org Mode
files containing configuration blocks and creating symbolic links
to those configuration files in the output directory, typically
the user's home directory."
  (interactive)
  (dotcrafter-tangle-org-files)
  (dotcrafter-link-config-files)
  (dotcrafter--update-gitignore))

(defun dotcrafter--org-mode-hook ()
  (add-hook 'after-save-hook #'dotcrafter--after-save-handler nil t))

(defun dotcrafter--after-save-handler ()
  (when (and dotcrafter-mode
             dotcrafter-tangle-on-save
             (member (file-name-nondirectory buffer-file-name) dotcrafter-org-files)
             (string-equal (directory-file-name (file-name-directory (buffer-file-name)))
                           (directory-file-name (expand-file-name dotcrafter-dotfiles-folder))))
    (message "Tangling %s..." (file-name-nondirectory buffer-file-name))
    (dotcrafter-tangle-org-file buffer-file-name)))

(defun dotcrafter--key (key)
  (kbd (concat dotcrafter-keymap-prefix " " key)))

(define-minor-mode dotcrafter-mode
  "Toggles global dotcrafter-mode."
  nil
  :global t
  :group 'dotfiles
  :lighter " dotcrafter"
  :keymap
  (list (cons (dotcrafter--key "t") #'dotcrafter-tangle-org-file)
        (cons (dotcrafter--key "u") #'dotcrafter-update-dotfiles))
  (if dotcrafter-mode
      (add-hook 'org-mode-hook #'dotcrafter--org-mode-hook)
    (remove-hook 'org-mode-hook #'dotcrafter--org-mode-hook)))

(provide 'dotcrafter)
